<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>icoParent</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>objObject</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Set variables
///Velocity &amp; limits
hsp = 0;
hsp_max = 10;
vsp = 0;
vsp_max = 10;
move_speed = 3;
move_factor = 1;
///Gravity
grav = 0.25;
grav_slide = 0.12;
grav_factor = 1;
///Friction
air_frict = 0.04;
ground_frict = 0.4;
frict_factor = 1;
///Acceleration
air_acc = 0.2;
ground_acc = 0.4;
acc_factor = 1;
///Jumping!
jump_height = 5;
djump_height = 3;
jump_factor = 1;
jumps_max = 1;
jumps = 0;

///Movement
move_x = 0;
move_y = 0;
move_jump = false;
can_move = true;

///Clinging
wall_jump = false; //can the entity wall-jump?
cling_left = false;
cling_right = false;
stick_time = 12; //number of steps needed to hold the left/right key before unsticking from the wall
stuck_time = 0;
slide_speed = 2;

///Climbing
climb_up = false;
climb_down = false;
climb_up_speed = 1;
climb_down_speed = 1;
ladder_stick = 10; //number of steps needed to hold the left/right key before unsticking from the ladder
ladder_stuck = 0;

///Ledge grab
can_grab = false; //can the entity grab ledges?
ledge_grab_block = noone; //the block which we're grabbed on to
ledge_grab_x = 0; //the x &amp; y position relative to the grabbed block
ledge_grab_y = 0;
ledge_stick = 10; //number of steps needed to hold the left/right key before unsticking from the ledge
ledge_stuck = 0;

///Damage stuff
hp = 1;
can_damage = true;
take_damage = 0; //Damage which will be taken next step
damager = noone; //The instance which last damaged this entity
fall_damage = 5; //Maximum fall damage
fall_damage_min_speed = 5;
fall_damage_max_speed = 10;
invincible = 0;
invincible_when_hit = false;

///Misc
ground = on_ground();
facing = 1;
white = 0; // &lt; flash white when damaged timer
state = state.normal;


                   


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Movement

//Implement factors
ground_acc *= acc_factor;
air_acc *= acc_factor;
ground_frict *= frict_factor;
air_frict *= frict_factor;
move_speed *= move_factor;
grav *= grav_factor;
grav_slide *= grav_factor;
jump_height *= jump_factor;
djump_height *= jump_factor;

//Check if on the ground
ground = check_collision(0, 1);

//State machine for each possible state that the entity can be in
switch (state)
{
    case state.normal:
        //Set acceleration &amp; friction
        if (ground)
        {
            acc = ground_acc;
            frict = ground_frict;
        }
        else
        {
            acc = air_acc;
            frict = air_frict;
        }
        //Gravity
        if (!ground)
        {
            vsp += grav;
        }
        //Horizontal Movement
        if (move_x &lt; 0)
        {
            if (hsp &gt;= -move_speed)
            {
                hsp = approach(hsp, move_speed*move_x, acc);
            }
            else
            {
                hsp = approach(hsp, move_speed*move_x, frict);
            }
        }
        else
        if (move_x &gt; 0)
        {
            if (hsp &lt;= move_speed)
            {
                hsp = approach(hsp, move_speed*move_x, acc);
            }
            else
            {
                hsp = approach(hsp, move_speed*move_x, frict);
            }
        }
        //Vertical movement
        if (move_y &lt; 0)
        {
            if (vsp &gt;= -move_speed)
            {
                vsp = approach(vsp, move_speed*move_y, acc);
            }
            else
            {
                vsp = approach(vsp, move_speed*move_y, frict);
            }
        }
        else
        if (move_y &gt; 0)
        {
            if (vsp &lt;= move_speed)
            {
                vsp = approach(vsp, move_speed*move_y, acc);
            }
            else
            {
                vsp = approach(vsp, move_speed*move_y, frict);
            }
        }
        //Check for walls
        if (wall_jump &amp;&amp; !ground)
        {
            cling_left = place_meeting(x-1, y, objSolid);
            cling_right = place_meeting(x+1, y, objSolid);
            if (cling_left || cling_right)
            {
                state = state.wall_slide;
                break;
            }
        }
        else
        {
            cling_left = false;
            cling_right = false;
        }
        //Friction
        if (move_x == 0)
        {
            hsp = approach(hsp, 0, frict);
        }
        if (move_y == 0 &amp;&amp; grav == 0)
        {
            vsp = approach(vsp, 0, frict);
        }
        //Jumping
        if (ground) jumps = 1;
        if (move_jump)
        {
            if (ground)
            {
                //Ground jump
                vsp = -jump_height*move_jump;
                ground = false;
                jumps = 1;
            }
            else
            {
                //Air jump (double jump)
                //check how many times we can jump
                if (jumps++ &lt; jumps_max || in_water)
                {
                    vsp = -djump_height*move_jump;
                }
            }
            move_jump = 0;
        }
        //Start climbing
        if (climb_up &amp;&amp; place_meeting(x, y-1, objLadder) &amp;&amp; !place_meeting(x, y-1, objSolid)) ||
           (climb_down &amp;&amp; place_meeting(x, y+1, objLadder) &amp;&amp; !place_meeting(x, y+1, objSolid))
        {
            state = state.climbing;
        }
        break;
    case state.wall_slide:
        //Face the correct direction
        if (cling_left) facing = 1; else facing = -1;
        //Check if the wall is still there!
        if (ground ||
           (cling_left &amp;&amp; !place_meeting(x-1, y, objSolid)) ||
           (cling_right &amp;&amp; !place_meeting(x+1, y, objSolid)))
        {
            cling_left = false;
            cling_right = false;
            state = state.normal;
            break;
        }
        //Gravity
        if (!ground)
        {
            if (vsp &gt;= 0)
            {
                vsp = approach(vsp, slide_speed, grav_slide);
            }
            else
            {
                vsp += grav;
            }
        }
        //Unsticking from the wall
        if (!ground)
        {
            if ((move_x &gt; 0 &amp;&amp; cling_left) || (move_x &lt; 0 &amp;&amp; cling_right))
            {
                if (stuck_time++ &gt;= stick_time)
                {
                    state = state.normal;
                    break;
                }
            }
            else
            {
                stuck_time = 0;
            }
        }
        //Wall jumping
        if (move_jump)
        {
            var jump_up_wall = -jump_height*move_jump;
            var jump_off_wall = jump_height*0.45;
            if (cling_left)
            {
                //Jump off left wall
                if (move_x &lt; 0)
                {
                    vsp = jump_up_wall;
                    hsp = jump_off_wall;
                }
                else
                {
                    vsp = -jump_height;
                    hsp = move_speed;
                }
            }
            else
            if (cling_right)
            {
                //Jump off right wall
                if (move_x &gt; 0)
                {
                    vsp = jump_up_wall;
                    hsp = -jump_off_wall;
                }
                else
                {
                    vsp = -jump_height;
                    hsp = -move_speed;
                }
            }
            jumps = 1;
            move_jump = 0;
            state = state.normal;
            break;
        }
        break;
    case state.climbing:
        //Set acceleration &amp; friction
        acc = 0;
        frict = 1;
        //Release from climbing
        if (move_x != 0 &amp;&amp; !climb_up &amp;&amp; !climb_down)
        {
            if (++ladder_stuck &gt;= ladder_stick || ground)
            {
                state = state.normal;
                break;
            }
        }
        else
        {
            ladder_stuck = 0;
        }
        //Friction
        if (move_x == 0)
        {
            hsp = approach(hsp, 0, frict);
        }
        if (move_y == 0)
        {
            vsp = approach(vsp, 0, frict);
        }
        //Jump off
        if (move_jump)
        {
            vsp = -djump_height;
            move_jump = false;
            state = state.normal;
            jumps = 1;
            break;
        }
        //Climbing movement
        var climb = false;
        if (climb_up)
        {
            var a = climb_up_speed;
            if (!place_meeting(x, y-a, objLadder))
            {
                state = state.normal;
            }
            if (!place_meeting(x, y-a, objSolid))
            {
                y -= a;
                climb = true;
            }
        }
        else
        if (climb_down)
        {
            var a = climb_down_speed;
            if (!place_meeting(x, y+a, objLadder) ||
                 place_meeting(x, y+a, objSolid))
            {
                state = state.normal;
            }
            if (!place_meeting(x, y+a, objSolid))
            {
                y += a;
                climb = true;
            }
        }
        //Move towards the centre of the ladder
        var ladder = instance_place(x, y, objLadder);
        if (ladder != noone)
        {
            x = approach(x, ladder.x, 0.5);
        }
        else
        {
            state = state.normal;
            break;
        }
        break;
    case state.ledge_grab:
        //Unsticking from the ledge by moving horizontally
        if (move_x &lt; 0)
        {
            if (facing == 1)
            {
                if (++ledge_stuck &gt; ledge_stick)
                {
                    state = state.normal;
                    break;
                }
            }
            else
            {
                move_x = 0;
            }
        }
        else
        if (move_x &gt; 0)
        {
            if (facing == -1)
            {
                if (++ledge_stuck &gt; ledge_stick)
                {
                    state = state.normal;
                    break;
                }
            }
            else
            {
                move_x = 0;
            }
        }
        else //if not moving horizontally, reset ledge stuck timer
        {
            ledge_stuck = 0;
        }
        //Jump off
        if (move_jump)
        {
            vsp = -djump_height;
            move_jump = false;
            state = state.normal;
            break;
        }
        //Unsticking by hitting down
        if (fallthrough)
        {
            state = state.normal;
        }
        //Check if the block we're grabbing still exists, if not... release!
        if (!instance_exists(ledge_grab_block))
        {
            state = state.normal;
            break;
        }
        else
        //Check for collisions with other blocks which would stop us from grabbing this block
        if (collision_rectangle(bbox_left, bbox_top-1, bbox_right, bbox_bottom+1, objSolid, true, true))
        {
            state = state.normal;
            x = xprevious;
            y = yprevious;
        }
        else
        //Stick to &amp; face the block we're grabbed on to
        {
            if (ledge_grab_block.x &lt; x) facing = -1 else facing = 1;
            x = ledge_grab_block.x+ledge_grab_x;
            y = ledge_grab_block.y+ledge_grab_y;
        }
        break;
}

//Check for grabbing a ledge
if (state == state.normal || state == state.wall_slide)
if (can_grab &amp;&amp; vsp &gt; 0 &amp;&amp; !fallthrough &amp;&amp; move_x != 0)
{
    //Set our grab points
    var gx = x+move_x*8;
    var gy = bbox_top+4;
    //Find the block in front of us (if any)
    var xx = x+hsp+move_x;
    var yy = y-2;
    var block = instance_place(xx, yy, objSolid);
    if (block != noone)
    {
        var grab_block = true;
        with (block)
        {
            //Make sure the block is within the confines of the room
            if (bbox_right &lt; 0 || bbox_left &gt; room_width ||
                bbox_bottom &lt; 0 || bbox_top &gt; room_height)
            {
                grab_block = false;
            }
            else
            //Make sure there's not a block above this one
            if (place_meeting(x, y-1, objSolid))
            {
                grab_block = false;
            }
        }
        if (grab_block)
        {
            //Set the block's grab points
            var target_gx = block.bbox_left;
            if (move_x &lt; 0) target_gx = block.bbox_right;
            target_gy = block.bbox_top;
            //Check if the grab points are in the correct positions
            if (gy &gt; target_gy-3 &amp;&amp; gy &lt; target_gy+3 &amp;&amp; !place_meeting(x, y, objSemiSolid))
            {
                state = state.ledge_grab;
                //Set x &amp; y positions
                var w = round((bbox_right-bbox_left)/2)+2;
                x = block.bbox_left-w;
                if (move_x &lt; 0) x = block.bbox_right+w;
                y = block.bbox_top+(bbox_bottom-bbox_top)-2;
                //Stop moving!
                vsp = 0;
                hsp = 0;
                move_x = 0;
                move_y = 0;
                //No more clinging to that wall for you
                cling_left = false;
                cling_right = false;
                //Set ledge grab position relative to the block
                ledge_grab_x = x-block.x;
                ledge_grab_y = y-block.y;
                ledge_grab_block = block;
            }
        }
    }
}

///Un-implement factors
ground_acc /= acc_factor;
air_acc /= acc_factor;
ground_frict /= frict_factor;
air_frict /= frict_factor;
move_speed /= move_factor;
grav /= grav_factor;
grav_slide /= grav_factor;
jump_height /= jump_factor;
djump_height /= jump_factor;

///Reset factors to 1
acc_factor = 1;
frict_factor = 1;
grav_factor = 1;
move_factor = 1;
jump_factor = 1;


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Fall damage!
if (fall_damage &gt; 0)
{
    ///If we're colliding horizontally or vertically...
    if (collide_x || collide_y)
    {
        ///Get absolute values. This removes negatives.
        var ahsp = abs(previous_hsp);
        var avsp = abs(previous_vsp);
        ///If we're moving at higher than min fall damage speed...
        if ((collide_x &amp;&amp; ahsp &gt; fall_damage_min_speed) ||
            (collide_y &amp;&amp; avsp &gt; fall_damage_min_speed))
        {
            ///Check which (horizontal/vertical) speed
            ///is currently higher
            var sp = avsp;
            if (ahsp &gt; avsp)
            {
                sp = ahsp;
            }
            if (sp &gt; fall_damage_min_speed)
            {
                //Minimum damage
                var min_damage = 1;
                //Damage based on speed
                var spd_damage = round((sp/fall_damage_max_speed)*fall_damage);
                //Take damage
                take_damage += max(min_damage, spd_damage);
            }
        }
    }
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Take damage
///Reduce flash white timer
if (white &gt; 0)
{
    white--;
}
///Reduce invincible timer
if (invincible &gt; 0)
{
    invincible--;
}
///Check for taking damage
if (can_damage)
{
    if (take_damage &gt; 0)
    {
        //Stop grabbing that ledge, bitch!
        ledge_grab = false;
        //If we're invincible, set the damage to 0
        if (invincible &gt; 0)
        {
            take_damage = 0;
        }
        else
        //If we become invincible when hit,
        //set invincible variable to 1 second
        if (invincible_when_hit)
        {
            invincible = room_speed*1.5;
        }
        //Create a "universal" hit effect
        create_effect(mid_x(), mid_y(), sprHitEffect, 0.5);
        //Reduce hp
        hp -= take_damage;
        take_damage = 0;
        //Destroy if we're out of hp
        if (hp &lt;= 0)
        {
            instance_destroy();
        }
        //Flash white for 8 steps
        white = 8;
    }
}   

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Wrap around room
wrap(8);


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw entity
///Flash if we're currently invincible
if (invincible &lt;= 0 || (floor(invincible/5) mod 3 != 0))
{
    ///Flash white if we've recently been hit
    if (white &gt; 0)
    {
        d3d_set_fog(true, c_white, 0, 1);
    }
    ///Draw the entity's sprite
    draw_sprite_ext(sprite_index, -1, x, y, xscale*facing, yscale, image_angle, image_blend, image_alpha);
    if (white &gt; 0)
    {
        d3d_set_fog(0, 0, 0, 0);
    }
}

///For test mode, draw a box showing the entity's bounding box
if (global.test_mode)
{
    draw_set_color(c_red);
    draw_rectangle(bbox_left, bbox_top, bbox_right, bbox_bottom, true);
    draw_set_color(c_white);
    draw_text(x, bbox_top-4, state);
}




</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>8,8</point>
  </PhysicsShapePoints>
</object>
